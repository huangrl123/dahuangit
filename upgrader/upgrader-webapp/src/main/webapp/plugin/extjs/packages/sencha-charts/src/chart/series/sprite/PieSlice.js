Ext.define("Ext.chart.series.sprite.PieSlice",{alias:"sprite.pieslice",mixins:{markerHolder:"Ext.chart.MarkerHolder"},extend:"Ext.draw.sprite.Sector",inheritableStatics:{def:{processors:{doCallout:"bool",rotateLabels:"bool",label:"string",labelOverflowPadding:"number",renderer:"default"},defaults:{doCallout:true,rotateLabels:true,label:"",labelOverflowPadding:10,renderer:null}}},config:{rendererData:null,rendererIndex:0},render:function(E,F,H,A){var G=this,D=G.attr,B={},C;if(D.renderer){B={type:"sector",text:D.text,centerX:D.centerX,centerY:D.centerY,margin:D.margin,startAngle:Math.min(D.startAngle,D.endAngle),endAngle:Math.max(D.startAngle,D.endAngle),startRho:Math.min(D.startRho,D.endRho),endRho:Math.max(D.startRho,D.endRho)};C=D.renderer.call(G,G,B,G.rendererData,G.rendererIndex);G.setAttributes(C);G.useAttributes(F,H)}G.callParent(arguments);if(D.label&&G.getBoundMarker("labels")){G.placeLabel()}},placeLabel:function(){var G=this,E=G.attr,O=G.attr.attributeId,J=Math.min(E.startAngle,E.endAngle),L=Math.max(E.startAngle,E.endAngle),T=(J+L)*0.5,N=E.margin,Q=E.centerX,V=E.centerY,I=Math.min(E.startRho,E.endRho)+N,U=Math.max(E.startRho,E.endRho)+N,M=(I+U)*0.5,D=G.surfaceMatrix,B=G.labelCfg||(G.labelCfg={}),R=G.getBoundMarker("labels")[0],F=R.getTemplate(),H=F.getCalloutLine(),P=H&&H.length||40,A,S,C,K;D.appendMatrix(E.matrix);B.text=E.label;S=Q+Math.cos(T)*M;C=V+Math.sin(T)*M;B.x=D.x(S,C);B.y=D.y(S,C);S=Q+Math.cos(T)*U;C=V+Math.sin(T)*U;B.calloutStartX=D.x(S,C);B.calloutStartY=D.y(S,C);S=Q+Math.cos(T)*(U+P);C=V+Math.sin(T)*(U+P);B.calloutPlaceX=D.x(S,C);B.calloutPlaceY=D.y(S,C);if(E.rotateLabels){B.rotationRads=T+Math.atan2(D.y(1,0)-D.y(0,0),D.x(1,0)-D.x(0,0))}else{B.rotationRads=0}B.calloutColor=(H&&H.color)||G.attr.fillStyle;if(H){if(H.width){B.calloutWidth=H.width}}else{B.calloutHasLine=false}B.globalAlpha=E.globalAlpha*E.fillOpacity;B.hidden=(E.startAngle==E.endAngle);if(F.attr.renderer){K=F.attr.renderer.call(G,G.attr.label,R,B,G.rendererData,G.rendererIndex);if(typeof K==="string"){B.text=K}else{Ext.apply(B,K)}}G.putMarker("labels",B,O);A=G.getMarkerBBox("labels",O,true);if(A){if(E.doCallout){if(F.attr.display==="outside"){G.putMarker("labels",{callout:1},O)}else{if(F.attr.display==="inside"){G.putMarker("labels",{callout:0},O)}else{G.putMarker("labels",{callout:1-G.sliceContainsLabel(E,A)},O)}}}else{G.putMarker("labels",{globalAlpha:G.sliceContainsLabel(E,A)},O)}}},sliceContainsLabel:function(E,J){var C=E.labelOverflowPadding,I=(E.endRho+E.startRho)/2,A=I+(J.width+C)/2,B=I-(J.width+C)/2,H,G,D,F;if(C<0){return 1}if(J.width+C*2>(E.endRho-E.startRho)){return 0}G=Math.sqrt(E.endRho*E.endRho-A*A);D=Math.sqrt(E.endRho*E.endRho-B*B);H=Math.abs(E.endAngle-E.startAngle);F=(H>Math.PI/2?B:Math.abs(Math.tan(H/2))*B);if(J.height+C*2>Math.min(G,D,F)*2){return 0}return 1}});