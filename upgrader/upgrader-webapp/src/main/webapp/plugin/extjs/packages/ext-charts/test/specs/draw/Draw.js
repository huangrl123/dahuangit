describe("Ext.draw.Draw",function(){var A;beforeEach(function(){var B=10000000000;A=function(D,C){return Math.round(D*B)===Math.round(C*B)};this.addMatchers({toEqualNumber:function(C){return A(this.actual,C)},toEqualAbsolutePath:function(F){var C=F.length,D,E;for(D=0;D<C;D++){E=F[D];if(typeof E==="number"){if(!A(this.actual[D],E)){return false}}}return true}})});describe("Ext.draw.Draw.ellipsePath",function(){it("should return path string from ellipse",function(){expect(Ext.draw.Draw.ellipsePath({attr:{x:-100,y:50,rx:10,ry:13}})).toEqual("M-100,37A10,13,0,1,1,-100,63A10,13,0,1,1,-100,37z")});it("should return path string from zero-radius ellipse",function(){expect(Ext.draw.Draw.ellipsePath({attr:{x:0,y:0,rx:0,ry:0}})).toEqual("M0,0A0,0,0,1,1,0,0A0,0,0,1,1,0,0z")})});describe("Ext.draw.Draw.rectPath",function(){it("should return path string from rectangle",function(){expect(Ext.draw.Draw.rectPath({attr:{x:-100,y:50,width:400,height:42}})).toEqual("M-100,50L300,50,300,92,-100,92z")});it("should return path string from rounded rectangle",function(){expect(Ext.draw.Draw.rectPath({attr:{radius:15,x:-100,y:50,width:400,height:42}})).toEqual("M-85,50l370,0a15,15,0,0,1,15,15l0,12a15,15,0,0,1,-15,15l-370,0a15,15,0,0,1,-15,-15l0,-12a15,15,0,0,1,15,-15z")})});describe("Ext.draw.Draw.quadratic2curve",function(){it("should convert simple 'quadratic' into 'cubic'",function(){expect(Ext.draw.Draw.quadratic2curve(-30,60,0,0,120,0)).toEqual([-10,20,40,0,120,0])});it("should convert complicated 'quadratic' into 'cubic'",function(){expect(Ext.draw.Draw.quadratic2curve(-30,60,3,12,120,-300)).toEqual([-8,28,42,-92,120,-300])})});describe("Ext.draw.Draw.arc2curve",function(){it("should convert simple 'arc' into two 'cubic' commands",function(){expect(Ext.draw.Draw.arc2curve(0,0,50,60,0,0,0,100,100).length).toEqual(12)});it("should correctly compute the initial cubic starting point",function(){expect(Ext.draw.Draw.arc2curve(0,0,50,60,0,0,0,100,100)[0]).toEqualNumber(-32.0750149717897);expect(Ext.draw.Draw.arc2curve(0,0,50,60,0,0,0,100,100)[1]).toEqualNumber(46.1880215183596)});it("should keep the arc end point the same as the cubic end point",function(){expect(Ext.draw.Draw.arc2curve(0,0,50,60,0,0,0,200,100)[10]).toEqual(200);expect(Ext.draw.Draw.arc2curve(0,0,50,60,0,0,0,200,100)[11]).toEqual(100)})});describe("Ext.draw.Draw.rotatePoint rotates (x,y) with (cx, cy) as the rotation center",function(){it("should return an object which has a property x (Number)",function(){expect(typeof Ext.draw.Draw.rotatePoint(100,50,0).x).toEqual("number")});it("should return an object which has a property y (Number)",function(){expect(typeof Ext.draw.Draw.rotatePoint(100,50,0).y).toEqual("number")});it("should return x:0 when rotating (0, 0) with 0 deg",function(){expect(Ext.draw.Draw.rotatePoint(0,0,0).x).toEqualNumber(0)});it("should return y:0 when rotating (0, 0) with 0 deg",function(){expect(Ext.draw.Draw.rotatePoint(0,0,0).y).toEqualNumber(0)});it("should return x:0 when rotating (100, 0) with 90 deg",function(){expect(Ext.draw.Draw.rotatePoint(100,0,90).x).toEqualNumber(0)});it("should return y:100 when rotating (0, 100) with 90 deg",function(){expect(Ext.draw.Draw.rotatePoint(100,0,90).y).toEqualNumber(100)});it("should return x:-100 when rotating (100, 0) with 180 deg",function(){expect(Ext.draw.Draw.rotatePoint(100,0,180).x).toEqualNumber(-100)});it("should return y:0 when rotating (0, 100) with 180 deg",function(){expect(Ext.draw.Draw.rotatePoint(100,0,180).y).toEqualNumber(0)});it("should return x:0 when rotating (100, 0) centered at (50, 0) with 180 deg",function(){expect(Ext.draw.Draw.rotatePoint(100,0,180,50,0).x).toEqualNumber(0)});it("should return y:0 when rotating (0, 100) centered at (50, 0) with 180 deg",function(){expect(Ext.draw.Draw.rotatePoint(100,0,180,50,0).y).toEqualNumber(0)})});describe("Ext.draw.Draw.rotate rotates (x,y) with the origin as the rotation center",function(){it("should return an object which has a property x (Number)",function(){expect(typeof Ext.draw.Draw.rotate(100,50,0).x).toEqual("number")});it("should return an object which has a property y (Number)",function(){expect(typeof Ext.draw.Draw.rotate(100,50,0).y).toEqual("number")});it("should return x:0 when rotating (0, 0) with 0 rad",function(){expect(Ext.draw.Draw.rotate(0,0,0).x).toEqualNumber(0)});it("should return y:0 when rotating (0, 0) with 0 rad",function(){expect(Ext.draw.Draw.rotate(0,0,0).y).toEqualNumber(0)});it("should return x:0 when rotating (100, 0) with PI/2 rad",function(){expect(Ext.draw.Draw.rotate(100,0,Math.PI/2).x).toEqualNumber(0)});it("should return y:100 when rotating (0, 100) with PI/2 rad",function(){expect(Ext.draw.Draw.rotate(100,0,Math.PI/2).y).toEqualNumber(100)});it("should return x:-100 when rotating (100, 0) with PI rad",function(){expect(Ext.draw.Draw.rotate(100,0,Math.PI).x).toEqualNumber(-100)});it("should return y:0 when rotating (0, 100) with PI/2 rad",function(){expect(Ext.draw.Draw.rotate(100,0,Math.PI).y).toEqualNumber(0)})});describe("Ext.draw.Draw.degrees converts from radian to degree",function(){it("should return a number",function(){expect(typeof Ext.draw.Draw.degrees(1)).toEqual("number")});it("should convert 0 rad to 0 deg",function(){expect(Ext.draw.Draw.degrees(0)).toEqual(0)});it("should convert 1 rad to 57.296 deg",function(){expect(Ext.draw.Draw.degrees(1)).toEqual(180/Math.PI)});it("should convert 2 rad to 114.592 deg",function(){expect(Ext.draw.Draw.degrees(2)).toEqual(360/Math.PI)});it("should convert 3 rad to 171.888 deg",function(){expect(Ext.draw.Draw.degrees(3)).toEqual(540/Math.PI)});it("should convert 7 rad to 41.07 deg",function(){expect(Ext.draw.Draw.degrees(7)).toEqual((1260/Math.PI)%360)});it("should convert PI rad to 180 deg",function(){expect(Ext.draw.Draw.degrees(Math.PI)).toEqual(180)});it("should convert 2*PI rad to 360 deg",function(){expect(Ext.draw.Draw.degrees(2*Math.PI)).toEqual(0)});it("should convert 3*PI rad to 180 deg",function(){expect(Ext.draw.Draw.degrees(3*Math.PI)).toEqual(180)});it("should convert 4*PI rad to 360 deg",function(){expect(Ext.draw.Draw.degrees(4*Math.PI)).toEqual(0)})});describe("Ext.draw.Draw.rad converts from degree to radian",function(){it("should return a number",function(){expect(typeof Ext.draw.Draw.rad(1)).toEqual("number")});it("should convert 0 deg to 0 rad",function(){expect(Ext.draw.Draw.rad(0)).toEqual(0)});it("should convert 90 deg to PI/2 rad",function(){expect(Ext.draw.Draw.rad(90)).toEqual(Math.PI/2)});it("should convert 180 deg to PI rad",function(){expect(Ext.draw.Draw.rad(180)).toEqual(Math.PI)});it("should convert 270 deg to 3*PI/2 rad",function(){expect(Ext.draw.Draw.rad(270)).toEqual(3*Math.PI/2)});it("should convert 360 deg to 0 rad",function(){expect(Ext.draw.Draw.rad(360)).toEqual(0)});it("should convert 540 deg to PI rad",function(){expect(Ext.draw.Draw.rad(540)).toEqual(Math.PI)});it("should convert 720 deg to 0 rad",function(){expect(Ext.draw.Draw.rad(720)).toEqual(0)})});describe("Ext.draw.Draw.rotateAndTranslatePath",function(){it("should return an absolute path even if there is no rotation or translation",function(){var B=[["M",0,0],["L",100,0],["L",100,100],["L",0,100],["Z"]];expect(Ext.draw.Draw.rotateAndTranslatePath({attr:{path:B},rotation:{degrees:0,x:0,y:0},translation:{x:0,y:0}})).toEqualAbsolutePath(B)});it("should be able to translate path only",function(){expect(Ext.draw.Draw.rotateAndTranslatePath({attr:{path:[["M",0,0],["L",100,0],["L",100,100],["L",0,100],["Z"]]},rotation:{degrees:0,x:0,y:0},translation:{x:100,y:100}})).toEqualAbsolutePath([["M",100,100],["L",200,100],["L",200,200],["L",100,200],["Z"]])});it("should be able to rotate path only",function(){expect(Ext.draw.Draw.rotateAndTranslatePath({attr:{path:[["M",0,0],["L",100,0],["L",100,100],["L",0,100],["Z"]]},rotation:{degrees:90,x:0,y:0},translation:{x:0,y:0}})).toEqualAbsolutePath([["M",0,0],["L",0,100],["L",-100,100],["L",-100,0],["Z"]])});it("should be able to do both simultaneously",function(){expect(Ext.draw.Draw.rotateAndTranslatePath({attr:{path:[["M",0,0],["L",100,0],["L",100,100],["L",0,100],["Z"]]},rotation:{degrees:90,x:0,y:0},translation:{x:100,y:100}})).toEqualAbsolutePath([["M",0,100],["L",0,200],["L",-100,200],["L",-100,100],["Z"]])})});describe("pathDimensions",function(){var B=[["M",0,0],["L",100,0],["L",100,50],["L",0,50],["Z"]];describe("a rectangle with origin in (0,0)",function(){it("should return an x:0 property",function(){expect(Ext.draw.Draw.pathDimensions(B).x).toBe(0)});it("should return an y:0 property",function(){expect(Ext.draw.Draw.pathDimensions(B).y).toBe(0)});it("should have an height of 50",function(){expect(Ext.draw.Draw.pathDimensions(B).height).toBe(50)});it("should have an width of 100",function(){expect(Ext.draw.Draw.pathDimensions(B).width).toBe(100)})})});describe("smooth",function(){describe("a simple path with (4 points connected by a line)",function(){var B;beforeEach(function(){B=Ext.draw.Draw.smooth([["M",0,0],["L",10,10],["L",20,0],["L",30,10]])});it("should have an initial position at 0 0",function(){expect(B[0][1]).toBe(0);expect(B[0][2]).toBe(0)});describe("bezier curves",function(){var C;it("should return a path with 3 bezier curves",function(){expect(B[1][0]).toBe("C");expect(B[2][0]).toBe("C");expect(B[3][0]).toBe("C")});describe("first bezier curve",function(){beforeEach(function(){C=B[1]});it("should have a first control point at 0 0",function(){expect(C[1]).toEqualNumber(0);expect(C[2]).toEqualNumber(0)});it("should have the second control point at west of the end point",function(){expect(C[3]<10).toBe(true);expect(C[4]).toEqualNumber(10)});it("should have the end point at 10 10",function(){expect(C[5]).toEqualNumber(10);expect(C[6]).toEqualNumber(10)})});describe("second bezier curve",function(){beforeEach(function(){C=B[2]});it("should have a first control point at east of origin point",function(){expect(C[1]>10).toBe(true);expect(C[2]).toEqualNumber(10)});it("should have the second control point at west of end point",function(){expect(C[3]>10).toBe(true);expect(C[4]).toEqualNumber(0)});it("should have the end point at 20 0",function(){expect(C[5]).toBe(20);expect(C[6]).toBe(0)})});describe("third bezier curve (the last one)",function(){beforeEach(function(){C=B[3]});it("should have a first control point at east of origin point",function(){expect(C[1]>20).toBe(true);expect(C[2]).toEqualNumber(0)});it("should have the second control point at 30 10",function(){expect(C[3]).toEqualNumber(30);expect(C[4]).toEqualNumber(10)});it("should have it's end point at 30 10",function(){expect(C[5]).toEqualNumber(30);expect(C[6]).toEqualNumber(10)})})})});describe("value argument reduce the convex hull size of each bezier curve when value is increased",function(){var E,D,B,C;beforeEach(function(){E=Ext.draw.Draw.smooth([["M",0,0],["L",10,10],["L",20,0],["L",30,10]]);D=Ext.draw.Draw.smooth([["M",0,0],["L",10,10],["L",20,0],["L",30,10]],10)});describe("second control point of the first curve",function(){it("should decrease distance between the second control point and end point",function(){B={x:E[1][3],y:E[1][4]};C={x:D[1][3],y:D[1][4]};expect(B.x<C.x).toBe(true);expect(B.y).toEqualNumber(C.y)})});describe("first control point of the second curve",function(){it("should decrease distance between the first control point and origin",function(){B={x:E[2][1],y:E[2][2]};C={x:D[2][1],y:D[2][2]};expect(B.x>C.x).toBe(true);expect(B.y).toEqualNumber(C.y)})});describe("second control point of the second curve",function(){it("should decrease distance between the second control point and end point",function(){B={x:E[2][3],y:E[2][4]};C={x:D[2][3],y:D[2][4]};expect(B.x<C.x).toBe(true);expect(B.y).toEqualNumber(C.y)})});describe("first control point of the third curve (last one)",function(){it("should decrease distance between the first control point and origin",function(){B={x:E[3][1],y:E[3][2]};C={x:D[3][1],y:D[3][2]};expect(B.x>C.x).toBe(true);expect(B.y).toEqualNumber(C.y)})})})});describe("snapEnds",function(){var B;beforeEach(function(){B=Ext.draw.Draw.snapEnds(0,100,10)});describe("returned object",function(){it("should have a from property equal to first argument",function(){expect(B.from).toEqual(0)});it("should have a to property greater than or equal to second argument",function(){expect(B.to>=100).toBe(true)});it("should have a steps property lesser than or equal to third argument",function(){expect(B.steps<=10).toBe(true)})})});describe("parseGradient",function(){var C,D,B=function(){it("should have an id inherited from the passed object",function(){expect(C.id).toBe(D.id)});it("should have a type inherited from the passed object",function(){expect(C.type).toBe(D.type||"linear")});describe("stops property",function(){var E;beforeEach(function(){E=C.stops});it("should be an array",function(){expect(Ext.isArray(E)).toBe(true)});describe("array members",function(){var H,G,F,I,J;beforeEach(function(){var L,K;H=E[0];G=E[1];F=[];I=[];J=[];L=D.stops;for(K in L){if(L.hasOwnProperty(K)){F.push(parseInt(K,10));I.push(L[K].color);J.push(L[K].opacity)}}});describe("first member",function(){it("should have color inherited from raw gradient or equal to #ffffff",function(){expect(H.color).toBe(Ext.draw.Color.toHex(I[0])||"#ffffff")});it("should have offset inherited from raw gradient",function(){expect(H.offset).toBe(F[0])});it("should have opacity inherited from raw gradient",function(){expect(H.opacity).toBe(J[0]||1)})});describe("second member",function(){it("should have color inherited from raw gradient or equal to #ffffff",function(){expect(G.color).toBe(Ext.draw.Color.toHex(I[1])||"#ffffff")});it("should have offset inherited from raw gradient",function(){expect(G.offset).toBe(F[1])});it("should have opacity inherited from raw gradient or equal to 1",function(){expect(G.opacity).toBe(J[1]||1)})})})})};describe("with a linear gradient object passed as first argument",function(){beforeEach(function(){D={id:"linear-1",angle:45,stops:{0:{color:"#0000ff",opacity:0.75},100:{color:"#ff0000",opacity:1}}};C=Ext.draw.Draw.parseGradient(D)});describe("returned gradient",function(){B();describe("vector property",function(){var E;beforeEach(function(){E=C.vector});it("should have an initial point in 0 0",function(){expect([E[0],E[1]]).toEqual([0,0])});it("should have a termination point in 1 1",function(){expect(1-E[2]).toEqualNumber(0);expect(1-E[3]).toEqualNumber(0)})})})});describe("with radial gradient object passed as first argument",function(){beforeEach(function(){D={id:"radial-1",type:"radial",centerX:1,centerY:2,focalX:3,focalY:4,radius:20,stops:{0:{opacity:0.5},100:{color:"rgb(255, 0, 0)"}}};C=Ext.draw.Draw.parseGradient(D)});describe("returned gradient",function(){B();it("should have centerX property inherited from the passed object",function(){expect(C.centerX).toEqual(D.centerX)});it("should have centerY property inherited from the passed object",function(){expect(C.centerY).toEqual(D.centerY)});it("should have focalX property inherited from the passed object",function(){expect(C.focalX).toEqual(D.focalX)});it("should have focalY property inherited from the passed object",function(){expect(C.focalY).toEqual(D.focalY)});it("should have radius property inherited from the passed object",function(){expect(C.radius).toEqual(D.radius)});it("should have an undefined vector property",function(){expect(C.vector).toBe(undefined)})})})})});