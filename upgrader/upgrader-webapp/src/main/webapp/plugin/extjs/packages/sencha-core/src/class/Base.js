Ext.Base=(function(A){var F=[],I,D=[],L=function(Q,P){var O=this,R,S,T;if(Q){S=Ext.Config.map[Q];if(!S){Ext.Logger.error("Invalid property name for getter: '"+Q+"' for '"+O.$className+"'.")}T=S.names.get;if(P&&O.hasOwnProperty(T)){R=O.config[Q]}else{R=O[T]()}}else{R=O.getCurrentConfig()}return R},J=function(Q,R,P){var O='"'+Q+'" is deprecated.';if(P){O+=" "+P}else{if(R){O+=' Please use "'+R+'" instead.'}}return function(){Ext.Error.raise(O)}},B=function(P,Q,R,O){if(!O){O='"'+Q+'" is deprecated.'}if(R){O+=' Please use "'+R+'" instead.'}if(O){Ext.Object.defineProperty(P,Q,{get:function(){Ext.Error.raise(O)},set:function(S){Ext.Error.raise(O)},configurable:true})}},E=function(O){return function(){return this[O].apply(this,arguments)}},G=Ext.Version,C=/^\d/,M={},K={},N=function(){},H=N.prototype;Ext.apply(N,{$className:"Ext.Base",$isClass:true,create:function(){return Ext.create.apply(Ext,[this].concat(Array.prototype.slice.call(arguments,0)))},addDeprecations:function(Z){var U=this,g=[],R=Ext.getCompatVersion(Z.name),Y=(U.$className||"")+"#",X,S,Q,d,c,f,a,e,P,b,O,W,T,V;for(S in Z){if(C.test(S)){V=new Ext.Version(S);V.deprecations=Z[S];g.push(V)}}g.sort(G.compare);for(Q=g.length;Q--;){X=(V=g[Q]).deprecations;c=U.prototype;T=X.statics;f=R&&R.lt(V);if(!f){}else{if(!f){break}}while(X){P=X.methods;if(P){for(b in P){W=P[b];e=null;if(!W){Ext.Assert.isNotDefinedProp(c,b);e=J(Y+b)}else{if(Ext.isString(W)){Ext.Assert.isNotDefinedProp(c,b);Ext.Assert.isDefinedProp(c,W);if(f){e=E(W)}else{e=J(Y+b,W)}}else{d="";if(W.message||W.fn){d=W.message;W=W.fn}a=c.hasOwnProperty(b)&&c[b];if(f&&W){W.$owner=U;W.$name=b;W.displayName=Y+b;if(a){W.$previous=a}e=W}else{if(!a){e=J(Y+b,null,d)}}}}if(e){c[b]=e}}}P=X.properties;if(P&&!f){for(b in P){O=P[b];if(Ext.isString(O)){B(c,Y+b,O)}else{if(O&&O.message){B(c,Y+b,null,O.message)}else{B(c,Y+b)}}}}X=T;T=null;c=U}}},extend:function(V){var S=this,U=V.prototype,T,Q,P,O,R;T=S.prototype=Ext.Object.chain(U);T.self=S;S.superclass=T.superclass=U;if(!V.$isClass){for(Q in H){if(Q in T){T[Q]=H[Q]}}}R=U.$inheritableStatics;if(R){for(Q=0,P=R.length;Q<P;Q++){O=R[Q];if(!S.hasOwnProperty(O)){S[O]=V[O]}}}if(V.$onExtended){S.$onExtended=V.$onExtended.slice()}S.getConfigurator()},$onExtended:[],triggerExtended:function(){Ext.classSystemMonitor&&Ext.classSystemMonitor(this,"Ext.Base#triggerExtended",arguments);var R=this.$onExtended,Q=R.length,P,O;if(Q>0){for(P=0;P<Q;P++){O=R[P];O.fn.apply(O.scope||this,arguments)}}},onExtended:function(O,P){this.$onExtended.push({fn:O,scope:P});return this},addStatics:function(O){this.addMembers(O,true);return this},addInheritableStatics:function(P){var R,Q,S=this.prototype,T,U;R=S.$inheritableStatics;Q=S.$hasInheritableStatics;if(!R){R=S.$inheritableStatics=[];Q=S.$hasInheritableStatics={}}var O=Ext.getClassName(this)+".";for(T in P){if(P.hasOwnProperty(T)){U=P[T];if(typeof U=="function"){U.displayName=O+T}this[T]=U;if(!Q[T]){Q[T]=true;R.push(T)}}}return this},addMembers:function(b,W,Y){var V=this,R=Ext.Function.clone,d=W?V:V.prototype,P=!W&&d.defaultConfig,U=Ext.enumerables,O=b.privates,Z,T,c,a,e,Q;var X=(V.$className||"")+"#";if(O){delete b.privates;Q=O.privacy||Y||"framework";V.addMembers(O,W,Q);O=O.statics;if(O&&!W){V.addMembers(O,true,Q)}}for(e in b){if(b.hasOwnProperty(e)){a=b[e];if(a&&a.$nullFn&&Y!==a.$privacy){Ext.Error.raise("Cannot use stock function for private method "+(V.$className?V.$className+"#":"")+e)}if(typeof a==="function"&&!a.$isClass&&!a.$nullFn){if(a.$owner){a=R(a)}if(d.hasOwnProperty(e)){a.$previous=d[e]}a.$owner=V;a.$name=e;a.displayName=X+e;var S=d[e];if(Y){if(Y===true){Y="framework"}a.$privacy=Y;if(S&&S.$privacy&&S.$privacy!==Y){Ext.privacyViolation(V,S,a,W)}}else{if(S&&S.$privacy){Ext.privacyViolation(V,S,a,W)}}}else{if(P&&(e in P)&&!d.config.hasOwnProperty(e)){(Z||(Z={}))[e]=a;continue}}d[e]=a}}if(Z){V.addConfig(Z)}if(U){for(T=0,c=U.length;T<c;++T){if(b.hasOwnProperty(e=U[T])){a=b[e];if(a&&!a.$nullFn){if(a.$owner){a=R(a)}a.$owner=V;a.$name=e;a.displayName=X+e;if(d.hasOwnProperty(e)){a.$previous=d[e]}}d[e]=a}}}return this},addMember:function(O,P){M[O]=P;this.addMembers(M);delete M[O];return this},borrow:function(Q,R){Ext.classSystemMonitor&&Ext.classSystemMonitor(this,"Ext.Base#borrow",arguments);var T=Q.prototype,O={},P,U,S;R=Ext.Array.from(R);for(P=0,U=R.length;P<U;P++){S=R[P];O[S]=T[S]}return this.addMembers(O)},override:function(S){var O=this,Q=S.statics,T=S.inheritableStatics,R=S.config,P=S.mixins,U=S.cachedConfig;if(Q||T||R){S=Ext.apply({},S)}if(Q){O.addMembers(Q,true);delete S.statics}if(T){O.addInheritableStatics(T);delete S.inheritableStatics}if(R){O.addConfig(R);delete S.config}if(U){O.addCachedConfig(U);delete S.cachedConfig}delete S.mixins;O.addMembers(S);if(P){O.mixin(P)}return O},callParent:function(P){var O;return(O=this.callParent.caller)&&(O.$previous||((O=O.$owner?O:O.caller)&&O.$owner.superclass.self[O.$name])).apply(this,P||F)},callSuper:function(P){var O;return(O=this.callSuper.caller)&&((O=O.$owner?O:O.caller)&&O.$owner.superclass.self[O.$name]).apply(this,P||F)},mixin:function(Q,S){var X=this,V,Z,Y,a,U,R,P,O,W;if(typeof Q!=="string"){W=Q;if(W instanceof Array){for(U=0,R=W.length;U<R;U++){V=W[U];X.mixin(V.prototype.mixinId||V.$className,V)}}else{for(var T in W){X.mixin(T,W[T])}}return}V=S.prototype;Z=X.prototype;if(V.onClassMixedIn){V.onClassMixedIn.call(S,X)}if(!Z.hasOwnProperty("mixins")){if("mixins" in Z){Z.mixins=Ext.Object.chain(Z.mixins)}else{Z.mixins={}}}for(Y in V){O=V[Y];if(Y==="mixins"){Ext.applyIf(Z.mixins,O)}else{if(!(Y==="mixinId"||Y==="config")&&(Z[Y]===undefined)){Z[Y]=O}}}a=V.$inheritableStatics;if(a){for(U=0,R=a.length;U<R;U++){P=a[U];if(!X.hasOwnProperty(P)){X[P]=S[P]}}}if("config" in V){X.addConfig(V.config,S)}Z.mixins[Q]=V;if(V.afterClassMixedIn){V.afterClassMixedIn.call(S,X)}return X},addConfig:function(O,Q){var P=this.$config||this.getConfigurator();P.add(O,Q)},addCachedConfig:function(Q,O){var R={},P;for(P in Q){R[P]={cached:true,$value:Q[P]}}this.addConfig(R,O)},getConfigurator:function(){return this.$config||new Ext.Configurator(this)},getName:function(){return Ext.getClassName(this)},createAlias:A(function(O,P){K[O]=function(){return this[P].apply(this,arguments)};this.override(K);delete K[O]})});for(I in N){if(N.hasOwnProperty(I)){D.push(I)}}N.$staticMembers=D;N.getConfigurator();N.addMembers({$className:"Ext.Base",isInstance:true,$configPrefixed:true,$configStrict:true,isConfiguring:false,isFirstInstance:false,statics:function(){var P=this.statics.caller,O=this.self;if(!P){return O}return P.$owner},callParent:function(S){var R,O=(R=this.callParent.caller)&&(R.$previous||((R=R.$owner?R:R.caller)&&R.$owner.superclass[R.$name]));if(!O){R=this.callParent.caller;var P,Q;if(!R.$owner){if(!R.caller){throw new Error("Attempting to call a protected method from the public scope, which is not allowed")}R=R.caller}P=R.$owner.superclass;Q=R.$name;if(!(Q in P)){throw new Error("this.callParent() was called but there's no such method ("+Q+") found in the parent class ("+(Ext.getClassName(P)||"Object")+")")}}return O.apply(this,S||F)},callSuper:function(S){var R,O=(R=this.callSuper.caller)&&((R=R.$owner?R:R.caller)&&R.$owner.superclass[R.$name]);if(!O){R=this.callSuper.caller;var P,Q;if(!R.$owner){if(!R.caller){throw new Error("Attempting to call a protected method from the public scope, which is not allowed")}R=R.caller}P=R.$owner.superclass;Q=R.$name;if(!(Q in P)){throw new Error("this.callSuper() was called but there's no such method ("+Q+") found in the parent class ("+(Ext.getClassName(P)||"Object")+")")}}return O.apply(this,S||F)},self:N,constructor:function(){return this},getConfigurator:function(){return this.$config||this.self.getConfigurator()},initConfig:function(Q){var O=this,P=O.getConfigurator();O.initConfig=Ext.emptyFn;O.initialConfig=Q||{};P.configure(O,Q);return O},beforeInitConfig:Ext.emptyFn,getConfig:L,setConfig:function(Q,R){var O=this,P;if(typeof Q==="string"){P=Ext.Config.map[Q];if(!P){Ext.Logger.error("Invalid property name for setter: '"+Q+"' for '"+this.$className+"'.")}this[P.names.set](R)}else{if(Q){O.getConfigurator().reconfigure(O,Q)}}return O},getCurrentConfig:function(){var O=this.getConfigurator();return O.getCurrentConfig(this)},hasConfig:function(O){return O in this.defaultConfig},getInitialConfig:function(P){var O=this.config;if(!P){return O}return O[P]},$links:null,link:function(P,Q){var O=this,R=O.$links||(O.$links={});R[P]=true;O[P]=Q;return Q},unlink:function(T){var R=this,O,P,Q,S;if(!Ext.isArray(T)){Ext.Error.raise("Invalid argument - expected array of strings")}for(O=0,P=T.length;O<P;O++){Q=T[O];S=R[Q];if(S){if(S.isInstance&&!S.isDestroyed){S.destroy()}else{if(S.parentNode&&"nodeType" in S){S.parentNode.removeChild(S)}}}R[Q]=null}return R},destroy:function(){var O=this,P=O.$links;O.destroy=Ext.emptyFn;O.isDestroyed=true;if(P){O.$links=null;O.unlink(Ext.Object.getKeys(P))}}});H.callOverridden=H.callParent;Ext.privacyViolation=function(T,W,S,R){var P=S.$name,U=W.$owner&&W.$owner.$className,O=R?"static ":"",X=S.$privacy?"Private "+O+S.$privacy+' method "'+P+'"':"Public "+O+'method "'+P+'"';if(T.$className){X=T.$className+": "+X}if(!W.$privacy){X+=U?" hides public method inherited from "+U:" hides inherited public method."}else{X+=U?" conflicts with private "+W.$privacy+" method declared by "+U:" conflicts with inherited private "+W.$privacy+" method."}var V=Ext.getCompatVersion();var Q=Ext.getVersion();if(Q&&V&&V.lt(Q)){Ext.log.error(X)}else{Ext.Error.raise(X)}};return N}(Ext.Function.flexSetter));