Ext.define("Ext.fx.easing.BoundMomentum",{extend:"Ext.fx.easing.Abstract",requires:["Ext.fx.easing.Momentum","Ext.fx.easing.Bounce"],config:{momentum:null,bounce:null,minMomentumValue:0,maxMomentumValue:0,minVelocity:0.01,startVelocity:0},applyMomentum:function(A,B){return Ext.factory(A,Ext.fx.easing.Momentum,B)},applyBounce:function(A,B){return Ext.factory(A,Ext.fx.easing.Bounce,B)},updateStartTime:function(A){this.getMomentum().setStartTime(A);this.callParent(arguments)},updateStartVelocity:function(A){this.getMomentum().setStartVelocity(A)},updateStartValue:function(A){this.getMomentum().setStartValue(A)},reset:function(){this.lastValue=null;this.isBouncingBack=false;this.isOutOfBound=false;return this.callParent(arguments)},getValue:function(){var H=this.getMomentum(),C=this.getBounce(),E=H.getStartVelocity(),B=E>0?1:-1,I=this.getMinMomentumValue(),F=this.getMaxMomentumValue(),A=(B==1)?F:I,D=this.lastValue,G,J;if(E===0){return this.getStartValue()}if(!this.isOutOfBound){G=H.getValue();J=H.getVelocity();if(Math.abs(J)<this.getMinVelocity()){this.isEnded=true}if(G>=I&&G<=F){return G}this.isOutOfBound=true;C.setStartTime(Ext.Date.now()).setStartVelocity(J).setStartValue(A)}G=C.getValue();if(!this.isEnded){if(!this.isBouncingBack){if(D!==null){if((B==1&&G<D)||(B==-1&&G>D)){this.isBouncingBack=true}}}else{if(Math.round(G)==A){this.isEnded=true}}}this.lastValue=G;return G}});