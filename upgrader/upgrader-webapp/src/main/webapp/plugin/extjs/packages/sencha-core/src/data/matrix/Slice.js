Ext.define("Ext.data.matrix.Slice",{stub:null,constructor:function(A,B){this.id=B;this.side=A;this.members={}},attach:function(A){var B=this;Ext.Assert.falsey(B.store,"Store is already attached");B.store=A;A.matrix=B;A.on("load",B.onStoreLoad,B,{single:true})},changeId:function(L){var I=this,K=I.id,C=I.side,F=C.slices,A=F[K],B=A.members,J=C.index,G=C.inverse.slices,E,H,D;I.id=L;F[L]=A;delete F[K];for(H in B){E=B[H];E[J]=L;D=G[H].members;D[L]=D[K];delete D[K]}},onStoreLoad:function(A){this.update(A.getData().items,0)},update:function(P,E){if(!(P instanceof Array)){Ext.Error.raise("Only array of records or record ids are supported")}var H=this,Q=Ext.data.matrix.Slice,C=H.side,M=C.index,A=P.length,J=H.id,N=H.members,O=C.inverse,R,L,F,D,I,G,K,B;for(F=0;F<A;++F){L=B=null;D=P[F];I=D.isEntity?(B=D).id:D;R=N[I];if(E<0&&R&&R[2]===1){delete N[I];K=O[I];if(K){delete K.members[J]}L=1}else{if(!R){R=[I,I,E];R[M]=J;N[I]=R;if(!(K=(G=O.slices)[I])){G[I]=K=new Q(O,I)}K.members[J]=R;L=1}else{if(E!==R[2]&&E!==0){R[2]=E;K=O.slices[I];L=1}}}if(L){if(H.notify){H.notify.call(H.scope,H,I,E)}if(K&&K.notify){K.notify.call(K.scope,K,J,E)}}}},destroy:function(){var B=this,A=B.store;if(A){A.matrix=null;A.un("load",B.onStoreLoad,B)}B.notify=B.scope=B.store=B.side=B.members=null;B.callParent()}});