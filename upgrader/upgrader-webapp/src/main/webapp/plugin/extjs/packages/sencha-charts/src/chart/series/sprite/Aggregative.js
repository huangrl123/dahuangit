Ext.define("Ext.chart.series.sprite.Aggregative",{extend:"Ext.chart.series.sprite.Cartesian",requires:["Ext.draw.LimitedCache","Ext.draw.SegmentTree"],inheritableStatics:{def:{processors:{dataHigh:"data",dataLow:"data",dataClose:"data"},aliases:{dataOpen:"dataY"},defaults:{dataHigh:null,dataLow:null,dataClose:null}}},config:{aggregator:{}},applyAggregator:function(A,B){return Ext.factory(A,Ext.draw.SegmentTree,B)},constructor:function(){this.callParent(arguments)},processDataY:function(){var C=this,F=C.attr,D=F.dataHigh,A=F.dataLow,B=F.dataClose,E=F.dataY;C.callParent(arguments);if(F.dataX&&E&&E.length>0){if(D){C.getAggregator().setData(F.dataX,F.dataY,D,A,B)}else{C.getAggregator().setData(F.dataX,F.dataY)}}},getGapWidth:function(){return 1},renderClipped:function(D,E,H,A){var F=this,G=Math.min(H[0],H[2]),B=Math.max(H[0],H[2]),C=F.getAggregator()&&F.getAggregator().getAggregation(G,B,(B-G)/A[2]*F.getGapWidth());if(C){F.dataStart=C.data.startIdx[C.start];F.dataEnd=C.data.endIdx[C.end-1];F.renderAggregates(C.data,C.start,C.end,D,E,H,A)}}});